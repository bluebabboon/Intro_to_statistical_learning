feature_type_function=function(data_frame)
for (i in names(data_frame))
{
feature_name=data_frame[[i]]
class_type = class(feature_name)
print(paste("Feature type for ",i,"is ",class_type))
}
feature_type_function(Auto_data)
print("blala",10)
print(paste("blala",10))
Range_function = function(data_frame)
for (i in names(data_frame))
{
data_type=class(data_frame[[i]])
if(data_type != "factor")                                           # Range will not work on factors ,so excluding that by if condition
{                                                                 # Also range returns a vector with two elements,min and max
featurerange=range(data_frame[,i])
print(paste("Range for ",i,"is ","from",featurerange[1],
"to",featurerange[2]))
}
}
Range_function(Auto_data)
substitute(mpg)
library(MASS)
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
pairs(boston_data)
getwd()
names(boston_data)
library(MASS)
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
pairs(boston_data)
names(boston_data)
colnames(boston_data)
pairs(~crim+zn+indus)
attach(boston_data)
pairs(~crim+zn+indus)
?Boston
pairs(crim)
source("Exercise_Problem_9.R")
source("Chapter_2/Exercise_Problem_9.R")
Range_function(boston_data)
12%%3
12%%7
12/7
round(1.75,0)
12/6
12*(1/3)
13*(1/3)
source("Chapter_2/user_functions.R")
pair_plotter_function(boston_data,crim)
pair_plotter_function(boston_data,crim)
pair_plotter_function = function(dataframe,subframe){
count=0
colcount=ncol(dataframe)
roundcolcount=round(colcount/3,0)
par(mfrow=c(roundcolcount,3))
for (i in names(dataframe))
{
color_inplot = colors(distinct = T)[count+20]
plot(subframe,dataframe[[i]],col=color_inplot,
xlab = deparse(substitute(subframe)),                            # substitue(feature_name),gives only feature_name as output;if we just give feature name,we will get array as output but we dont want that
ylab = i)                                                        # deparse() function will convert whatever present inside to strings
count=count+1
}
}
pair_plotter_function(boston_data,crim)
pair_plotter_function(boston_data,crim)
pair_plotter_function(boston_data,crim)
# Loading the dataset from MASS library
# This data frame contains the following columns:
#
# crim -    per capita crime rate by town.
# zn -      proportion of residential land zoned for lots over 25,000 sq.ft.
# indus -   proportion of non-retail business acres per town.
# chas -    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
# nox -     nitrogen oxides concentration (parts per 10 million).
# rm -      average number of rooms per dwelling.
# age -     proportion of owner-occupied units built prior to 1940.
# dis -     weighted mean of distances to five Boston employment centres.
# rad -     index of accessibility to radial highways.
# tax -     full-value property-tax rate per \$10,000.
# ptratio - pupil-teacher ratio by town.
# black -   1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
# lstat -   lower status of the population (percent).
# medv -    median value of owner-occupied homes in \$1000s
library(MASS)
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function = function(dataframe,subframe){
count=0
colcount=ncol(dataframe)
roundcolcount=round(colcount/3,0)
par(mfrow=c(roundcolcount,3))
for (i in names(dataframe))
{
color_inplot = colors(distinct = T)[count+20]
plot(subframe,dataframe[[i]],col=color_inplot,
xlab = deparse(substitute(subframe)),                            # substitue(feature_name),gives only feature_name as output;if we just give feature name,we will get array as output but we dont want that
ylab = i)                                                        # deparse() function will convert whatever present inside to strings
count=count+1
}
}
pair_plotter_function(boston_data,crim)
ncol(boston_data)
14/3
colcount=ncol(boston_data)
colcount
roundcolcount=round(colcount/3,0)
roundcolcount
par(mfrow=c(5,3))
plot(crim,zn)
par(mfrow=c(3,3))
plot(crim,zn)
par(mfrow=c(5,5))
plot(crim,zn)
par("mar")
par(mfrow=c(5,5),mar=c(1,1,1,1))
plot(crim,zn)
# Loading the dataset from MASS library
# This data frame contains the following columns:
#
# crim -    per capita crime rate by town.
# zn -      proportion of residential land zoned for lots over 25,000 sq.ft.
# indus -   proportion of non-retail business acres per town.
# chas -    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
# nox -     nitrogen oxides concentration (parts per 10 million).
# rm -      average number of rooms per dwelling.
# age -     proportion of owner-occupied units built prior to 1940.
# dis -     weighted mean of distances to five Boston employment centres.
# rad -     index of accessibility to radial highways.
# tax -     full-value property-tax rate per \$10,000.
# ptratio - pupil-teacher ratio by town.
# black -   1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
# lstat -   lower status of the population (percent).
# medv -    median value of owner-occupied homes in \$1000s
library(MASS)
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function(boston_data,crim)
# Loading the dataset from MASS library
# This data frame contains the following columns:
#
# crim -    per capita crime rate by town.
# zn -      proportion of residential land zoned for lots over 25,000 sq.ft.
# indus -   proportion of non-retail business acres per town.
# chas -    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
# nox -     nitrogen oxides concentration (parts per 10 million).
# rm -      average number of rooms per dwelling.
# age -     proportion of owner-occupied units built prior to 1940.
# dis -     weighted mean of distances to five Boston employment centres.
# rad -     index of accessibility to radial highways.
# tax -     full-value property-tax rate per \$10,000.
# ptratio - pupil-teacher ratio by town.
# black -   1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
# lstat -   lower status of the population (percent).
# medv -    median value of owner-occupied homes in \$1000s
library(MASS)
source("Chapter_2/user_functions.R")
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function(boston_data,crim)
# Loading the dataset from MASS library
# This data frame contains the following columns:
#
# crim -    per capita crime rate by town.
# zn -      proportion of residential land zoned for lots over 25,000 sq.ft.
# indus -   proportion of non-retail business acres per town.
# chas -    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
# nox -     nitrogen oxides concentration (parts per 10 million).
# rm -      average number of rooms per dwelling.
# age -     proportion of owner-occupied units built prior to 1940.
# dis -     weighted mean of distances to five Boston employment centres.
# rad -     index of accessibility to radial highways.
# tax -     full-value property-tax rate per \$10,000.
# ptratio - pupil-teacher ratio by town.
# black -   1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
# lstat -   lower status of the population (percent).
# medv -    median value of owner-occupied homes in \$1000s
library(MASS)
source("Chapter_2/user_functions.R")
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function(boston_data,crim)
dev.off()
image(boston_data)
image(as.matrix(boston_data))
x=seq(10)
x
y=seq(10)
z=outer(x,y,function(x,y) cos(y)/(1+x^2))
z
na.fail(boston_data)
is.na(boston_data)
summary(chas)
# Loading the dataset from MASS library
# This data frame contains the following columns:
#
# crim -    per capita crime rate by town.
# zn -      proportion of residential land zoned for lots over 25,000 sq.ft.
# indus -   proportion of non-retail business acres per town.
# chas -    Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
# nox -     nitrogen oxides concentration (parts per 10 million).
# rm -      average number of rooms per dwelling.
# age -     proportion of owner-occupied units built prior to 1940.
# dis -     weighted mean of distances to five Boston employment centres.
# rad -     index of accessibility to radial highways.
# tax -     full-value property-tax rate per \$10,000.
# ptratio - pupil-teacher ratio by town.
# black -   1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
# lstat -   lower status of the population (percent).
# medv -    median value of owner-occupied homes in \$1000s
library(MASS)
source("Chapter_2/user_functions.R")
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function(boston_data,crim)
summary(chas)
count.fields(chas)
str(chas)
dim(chas)
sum(chas)
fix(boston_data)
sum(boston_data)
rowsum(chas)
colSums(chas)
colsum(chas)
x=cbind(x1=3,x2=c(4:1,2:5))
x
rowSums(x)
colSums(x)
colSums(boston_data["chas","zn"])
boston_data["chas"]
boston_data["chas","zn"]
boston_data["chas"]
boston_data[["chas","zn"]]
boston_data[chas]
boston_data[crim]
boston_data[crim]
boston_data[[chas]]
boston_data[["chas"]]
boston_data[,c("chas","zn")]
fix(boston_data)
fix(boston_data)
?boston
?Boston
library(MASS)
?Boston
source("Chapter_2/user_functions.R")
getwd()
boston_data=Boston
?Boston
names(boston_data)
str(boston_data)
summary(boston_data)
dim(boston_data)
fix(boston_data)
attach(boston_data)
pairs(boston_data)
pairs(~crim+zn+indus)
pair_plotter_function(boston_data,crim)
sum(chas)
names(boston_data)
rownames(boston_data)
dim(boston_data)
?sort
sort(crim)
fix(boston_data)
pair_plotter_function(boston_data,crim)
names(boston_data)
hist(crim)
tax
plot(crim,ptratio)
plot(crim,ptratio)
plot(crim,black)
plot(crim,lstat)
plot(crim,nox)
plot(crim,age)
plot(crim,medv)
plot(crim,tax)
plot(crim,rad)
plot(crim,indus)
plot(crim,rm)
median(ptratio)
mean(ptratio)
median(ptratio)
min(medv)
max(medv)
boston_data[medv < 10]
boston_data[medv < 10,]
boston_data[medv == 5,]
min(medv)
boston_data[medv==min(medv)]
boston_data[medv==min(medv),]
c(1,2,3)
arbit=data.frame(x1=c(1,2,3),x2=c(3,4,5))
arbit
?data.frame
arbit=data.frame(x1=c(1,2,3),x2=c(3,4,5),byrow=T)
arbit
?rbind
arbit
arbit=arbit[,c(1:2)]
arbit
arbit=rbind(arbit,c(3,44))
arbit
range(boston_data)
range(crim)
minrow=c(1)
minrow
rep(x,3)
rep(4,3)
x
rep(0,5)
k=rep(0,c(4,4))
rep(0,4,4)
rep(0,c(2,2))
min(boston_data[["crim"]])
adds_min_max=function(dataframe)
{
minrow=rep(0,ncol(dataframe))
maxrow=rep(0,ncol(dataframe))
count=1
for(i in names(dataframe))
{
minrow[count] = min(dataframe[[i]])
maxrow[count] = max(dataframe[[i]])
}
outputframe=rbind(minrow,maxrow)
return(outputframe)
}
adds_min_max(boston_data)
adds_min_max=function(dataframe)
{
minrow=rep(0,ncol(dataframe))
maxrow=rep(0,ncol(dataframe))
count=1
for(i in names(dataframe))
{
minrow[count] = min(dataframe[[i]])
maxrow[count] = max(dataframe[[i]])
count=count+1
}
outputframe=rbind(minrow,maxrow)
return(outputframe)
}
adds_min_max(boston_data)
arbit=adds_min_max(boston_data)
arbit
arbit2=rbind(boston_data,arbit)
colnames(boston_data)
colnames(arbit)
colnames(arbit)=colnames(boston_data)
colnames(arbit)
adds_min_max=function(dataframe)
{
minrow=rep(0,ncol(dataframe))
maxrow=rep(0,ncol(dataframe))
count=1
for(i in names(dataframe))
{
minrow[count] = min(dataframe[[i]])
maxrow[count] = max(dataframe[[i]])
count=count+1
}
outputframe=rbind(minrow,maxrow)
colnames(outputframe)=colnames(dataframe)
return(outputframe)
}
arbit=adds_min_max(boston_data)
arbit
arbit2=rbind(boston_data,arbit)
fix(arbit2)
boston_data[medv==min(medv),]
x
c(2,1:9)
pair_plotter_function(boston_data,crim)
names(boston_data)
mean(crim)
suburbs_more_crime=boston_data[,crim>mean(crim)]
suburbs_more_crime=boston_data[,crim > mean(crim)]
boston_data[,"crim"]
suburbs_more_crime = boston_data[,"crim" > mean(crim)]
View(suburbs_more_crime)
suburbs_more_crime = boston_data["crim" > mean(crim),]
View(suburbs_more_crime)
boston_data[crim > 5]
boston_data[crim > 5,]
arbot=boston_data[crim > 3]
arbot=boston_data[crim > 3,]
mean(crim)
suburbs_more_crime = boston_data["crim" > mean(crim),]
suburbs_more_crime = boston_data["crim" > mean("crim"),]
suburbs_more_crime = boston_data[crim > mean(crim),]
View(suburbs_more_crime)
row.names(suburbs_more_crime)
row.names(suburbs_more_crime)
range(crim)
View(suburbs_more_crime)
x
rowSums(z)
rowSums(x)
x[2,1]=NA
x
rowSums(is.na(x))
?with
with(mtcars,mpg[cyl==8 & disp > 350])
mpg
crim[]
crim[age > mean(age) & medv > mean(medv)]
crim[age > mean(age) & medv < mean(medv)]
suburbs_more_crime = boston_data[dis < mean(dis) & medv<mean(medv) & rm>mean(rm)]
suburbs_more_crime = boston_data[dis < mean(dis) & medv<mean(medv) & rm>mean(rm),]
View(suburbs_more_crime)
mean(suburbs_more_crime[crim,])
suburbs_more_crime[crim,]
suburbs_more_crime$crim
boston_data[,crim]
boston_data[,c(crim)]
boston_data[crim]
boston_data[crim,]
suburbs_more_crime = boston_data[dis < mean(dis) & medv<mean(medv) & rm>mean(rm),]
suburbs_more_crime[,crim]
suburbs_more_crime[,"crim"]
names(suburbs_more_crime)
suburbs_more_crime = subset(suburbs_more_crime,select = c("crim","medv","rm"))
View(suburbs_more_crime)
mean(suburbs_more_crime[crim,])
mean(suburbs_more_crime["crim",])
mean(suburbs_more_crime[,"crim"])
median(ptratio)
min(medv)
row.names(boston_data[,medv==min(medv)])
row.names(boston_data[medv==min(medv),])
row.names(boston_data[medv==min(medv),])                                                                    # Remember the syntax for selecting certain row based on given conditions in columns dataframe[dataframe$col1=="some value",]
boston_data["140",]
low_medv_rows=row.names(boston_data[medv==min(medv),])
low_medv_rows
typeof(low_medv_rows)
boston_data[low_medv_rows,]
str(boston_data)
morethan7rooms = boston_data[rm > 7,]
View(morethan7rooms)
mean(morethan7rooms)
mean(boston_data)
mean(morethan7rooms$crim)
View(morethan7rooms)
View(boston_data)
class(boston_data)
nrow(morethan7rooms)
range(morethan7rooms$rm)
morethan8rooms = boston_data[rm > 8,]
nrow(morethan8rooms)
View(morethan8rooms)
mean(morethan8rooms$crim)
